# -*- coding: utf-8 -*-
"""Home_Ownership_MSDS460_Assignment3[MS].ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q3FF9lMCbWG0XT8VsyJjHSh4f8w9ZxLU

# MSDS460 - Assignment 3: Integer Programming Example---Algorithmic Redistricting

**Chosen State:** Virginia

Used Data Sources:
* [Wikipedia](https://en.wikipedia.org/wiki/List_of_cities_and_counties_in_Virginia#cite_note-wwwcensusgov2-8) for a list of counties and populations
* [US Census Data](https://www2.census.gov/geo/docs/reference/county_adjacency/county_adjacency2024.txt) for adjacency data
* [Virginia Administrative Boundaries](https://vgin.vdem.virginia.gov/datasets/777890ecdb634d18a02eec604db522c6/about)
* [Virginia Congressional District](https://www.arcgis.com/home/item.html?id=777890ecdb634d18a02eec604db522c6)


Group Members:
* Albert Lee
* Albert Olea
* Maddie Stapulionis
* Migus Wong
* Thomas Young

>[MSDS460 - Assignment 3: Integer Programming Example---Algorithmic Redistricting](#scrollTo=RwopTi9PA7pc)

>>[Group Discussion Points](#scrollTo=u2IZpMexBko9)

>>[Data Collection](#scrollTo=7TUZJ7Z1BR3n)

>>>[District Information](#scrollTo=qM6C53zCE-H7)

>>[County Visualization](#scrollTo=4Zk9UsgsVEMV)

>>[Base Model](#scrollTo=khD_RnZ-hnUN)

>>[Adding Contiguity](#scrollTo=Jm8Blam8w1ao)

## Group Discussion Points

* How shall we define "fairness" in the assignment of counties to congressional districts?

* The specification of constraints can be difficult, and the number of constraints can be large. Having a team of students working on this makes sense.

* There may be a need to test many alternative solutions and to "tweak" solutions to the integer program that is developed.

* Integer programs can take a long time to run and may require lots of memory. So, it is a good idea to get started on this assignment early, and it may be useful to have more than one person running the programs or trying alternative versions of programs.

## Data Collection

### District Information
"""

import pandas as pd

# URL of the Wikipedia page
url = "https://en.wikipedia.org/wiki/List_of_cities_and_counties_in_Virginia#cite_note-wwwcensusgov2-8"

# Read the first table from the URL into a pandas DataFrame
try:
  tables = pd.read_html(url)
  county_table = tables[2]
  city_table = tables[3]

except IndexError:
  print("No tables found on the page or an error occurred during scraping.")

except Exception as e:
  print(f"An error occurred: {e}")

county_table.head()

city_table.head()

county_df = county_table[['County', 'Population[8]']]
county_df.rename(columns={'Population[8]': 'Population'}, inplace=True)

city_df = city_table[['City', 'Population[11]']]
city_df.rename(columns={'Population[11]': 'Population'}, inplace=True)
city_df['City'] = city_df['City'] + " city"
city_df.head()

# Download the text file
!wget https://www2.census.gov/geo/docs/reference/county_adjacency/county_adjacency2024.txt

# Read the file into a pandas DataFrame, specifying the delimiter
try:
  adjacency_df = pd.read_csv("county_adjacency2024.txt", delimiter="|", header=0)
  print(adjacency_df.head())
except Exception as e:
  print(f"An error occurred: {e}")

county_df.rename(columns={'County': 'County/City'}, inplace=True)
city_df.rename(columns={'City': 'County/City'}, inplace=True)
df = pd.concat([county_df, city_df], ignore_index=True)
df.head()

# Filter rows where both 'County Name' and 'Neighbor Name' contain ", VA"
filtered_df = adjacency_df[
    adjacency_df['County Name'].str.contains(", VA") & adjacency_df['Neighbor Name'].str.contains(", VA")
]

# Remove ", VA" from 'County Name' and 'Neighbor Name' columns
filtered_df['County Name'] = filtered_df['County Name'].str.replace(', VA', '')
filtered_df['Neighbor Name'] = filtered_df['Neighbor Name'].str.replace(', VA', '')

# Remove rows where 'County GEOID' equals 'Neighbor GEOID'
filtered_df = filtered_df[filtered_df['County GEOID'] != filtered_df['Neighbor GEOID']]

filtered_df.head()

# Unique county names in the original DataFrame
df_counties = set(df['County/City'].unique())

# Unique county names in the filtered DataFrame
filtered_counties = set(filtered_df['County Name'].unique())

# Counties present in df but not in filtered_df
counties_only_in_df = df_counties - filtered_counties

# Counties present in filtered_df but not in df
counties_only_in_filtered = filtered_counties - df_counties

# Print the results
print("Counties present in df but not in filtered_df:")
for county in counties_only_in_df:
    print(county)

print("\nCounties present in filtered_df but not in df:")
for county in counties_only_in_filtered:
    print(county)

len(filtered_df['County Name'].unique())

aggregated_df = filtered_df.groupby(['County Name', 'County GEOID']).agg(
    {'Neighbor Name': list, 'Neighbor GEOID': list}
).reset_index()

aggregated_df.rename(columns={'Neighbor Name': 'Neighbor Names', 'Neighbor GEOID': 'Neighbor GEOIDs'}, inplace=True)

print(aggregated_df.head())

chosen_state = 'Virginia'
num_districts = 11

population_sum = df['Population'].sum()
print(f"The sum of the population is: {population_sum:,}")
print(f"The number of counties/independent cities in {chosen_state} is: {len(df)}")
print(f"The number of districts in {chosen_state} is: {num_districts}")

target_population = population_sum // num_districts
print(f"The target population is: {target_population:,} per district")

print("\nDistricts over target population:")
over_target_df = df[df['Population'] > target_population]
print(over_target_df)

df = pd.merge(df, aggregated_df, left_on='County/City', right_on='County Name', how='inner').drop(columns=['County Name'])

import pandas as pd

# Create a dictionary of homeownership rates for each county
homeownership_rates = {
    "Accomack County":	68.78409,
    "Albemarle County":	70.12396,
    "Alexandria City":	43.53202,
    "Alleghany County":	79.76027,
    "Amelia County":	80.00757,
    "Amherst County":	80.08371,
    "Appomattox County":	77.15789,
    "Arlington County":	48.02977,
    "Augusta County":	81.12794,
    "Bath County":	70.66294,
    "Bedford City":	65,
    "Bedford County":	85.45981,
    "Bland County":	76.55303,
    "Botetourt County":	87.8883,
    "Bristol City":	66.59289,
    "Brunswick County":	68.98669,
    "Buchanan County":	80.91021,
    "Buckingham County":	74.53098,
    "Buena Vista City":	58.30033,
    "Campbell County":	78.07618,
    "Caroline County":	82.3192,
    "Carroll County":	76.8283,
    "Charles City County":	84.57972,
    "Charlotte County":	70.59915,
    "Charlottesville City":	46.14828,
    "Chesapeake City":	76.52256,
    "Chesterfield County":	78.73646,
    "Clarke County":	84.65963,
    "Colonial Heights City":	72.46007,
    "Covington City":	72.40824,
    "Craig County":	88.04191,
    "Culpeper County":	74.80606,
    "Cumberland County":	77.55922,
    "Danville City":	47.52132,
    "Dickenson County":	75.52021,
    "Dinwiddie County":	77.79933,
    "Emporia City":	33.55494,
    "Essex County":	70.12591,
    "Fairfax City":	69.6712,
    "Fairfax County":	70.24715,
    "Falls Church City":	57.78284,
    "Fauquier County":	80.35807,
    "Floyd County":	82.22265,
    "Fluvanna County":	90.53487,
    "Franklin City":	47.09454,
    "Franklin County":	80.07794,
    "Frederick County":	80.28485,
    "Fredericksburg City":	47.02616,
    "Galax City":	66.63016,
    "Giles County":	79.11473,
    "Gloucester County":	81.80231,
    "Goochland County":	88.38115,
    "Grayson County":	80.74747,
    "Greene County":	77.54915,
    "Greensville County":	62.31443,
    "Halifax County":	72.06424,
    "Hampton City":	58.16798,
    "Hanover County":	84.71229,
    "Harrisonburg City":	40.398,
    "Henrico County":	67.31163,
    "Henry County":	77.83409,
    "Highland County":	89.88962,
    "Hopewell City":	52.81482,
    "Isle of Wight County":	84.31277,
    "James City County":	80.89182,
    "King and Queen County":	71.15039,
    "King George County":	78.5869,
    "King William County":	89.80997,
    "Lancaster County":	80.57676,
    "Lee County":	75.34527,
    "Lexington City":	50.02396,
    "Loudoun County":	81.20593,
    "Louisa County":	82.44883,
    "Lunenburg County":	71.80369,
    "Lynchburg City":	52.25775,
    "Madison County":	78.59235,
    "Manassas City":	70.39741,
    "Manassas Park City":	71.18794,
    "Martinsville City":	60.30912,
    "Mathews County":	84.35374,
    "Mecklenburg County":	71.69228,
    "Middlesex County":	82.73298,
    "Montgomery County":	55.29721,
    "Nelson County":	79.98227,
    "New Kent County":	91.03372,
    "Newport News City":	49.94065,
    "Norfolk City":	48.7666,
    "Northampton County":	66.91189,
    "Northumberland County":	89.49938,
    "Norton City":	56.06061,
    "Nottoway County":	69.22665,
    "Orange County":	79.82696,
    "Page County":	71.05151,
    "Patrick County":	80.54909,
    "Petersburg City":	40.22761,
    "Pittsylvania County":	78.15617,
    "Poquoson City":	86.6341,
    "Portsmouth City":	57.00036,
    "Powhatan County":	94.36696,
    "Prince Edward County":	63.81602,
    "Prince George County":	69.34708,
    "Prince William County":	76.40833,
    "Pulaski County":	72.65608,
    "Radford City":	42.07854,
    "Rappahannock County":	73.19546,
    "Richmond City":	46.48633,
    "Richmond County":	70.5161,
    "Roanoke City":	53.78448,
    "Roanoke County":	78.91381,
    "Rockbridge County":	78.46251,
    "Rockingham County":	74.92478,
    "Russell County":	75.83717,
    "Salem City":	70.20898,
    "Scott County":	78.51017,
    "Shenandoah County":	73.64099,
    "Smyth County":	72.22858,
    "Southampton County":	76.72627,
    "Spotsylvania County":	82.02686,
    "Stafford County":	82.37588,
    "Staunton City":	63.1444,
    "Suffolk City":	72.46989,
    "Surry County":	81.74603,
    "Sussex County":	67.80461,
    "Tazewell County":	73.58771,
    "Virginia Beach City":	67.44434,
    "Warren County":	77.4685,
    "Washington County":	78.11981,
    "Waynesboro City":	65.41044,
    "Westmoreland County	":	79.68649,
    "Williamsburg City":	52.63696,
    "Winchester City":	45.85613,
    "Wise County":	73.99682,
    "Wythe County":	79.71573,
    "York County": 72.06923

}

# List of counties
counties = list(homeownership_rates.keys())

# Convert to a DataFrame
homeownership_df = pd.DataFrame(list(homeownership_rates.items()), columns=["County/City", "Homeownership Rate"])

# Calculate the target homeownership rate (in this case, 69.1% for Virginia)
target_homeownership_rate = 69.1

# Ensure consistent county names
homeownership_df['County/City'] = homeownership_df['County/City'].str.strip()

# Merge election_df with df to get County GEOID

df = pd.merge(df, homeownership_df, left_on='County/City', right_on='County/City', how='left')

# Compute the average homeownership percentage from homeownership_df (excluding NaN values)
average_homeownership = homeownership_df['Homeownership Rate'].mean()

# Fill NaN values in the 'Homeownership_Percentage' column with the average
df['Homeownership_Percentage'] = df['Homeownership Rate'].fillna(average_homeownership)

average_homeownership = df['Homeownership Rate'].mean()
df['Homeownership_Percentage'] = df['Homeownership Rate'].fillna(average_homeownership)


# Set County GEOID as index
df.set_index('County GEOID', inplace=True)

df

df['County/City'] = df['County/City'].str.replace('city', 'City')

"""## County Visualization"""

!pip install geopandas

from google.colab import drive
drive.mount('/content/drive',force_remount=True)

import os
!mkdir -p "/content/drive/MyDrive/ColabFiles"

import geopandas as gpd
import folium
import matplotlib.pyplot as plt
from matplotlib.colors import to_hex

gdf = gpd.read_file('/content/drive/MyDrive/MSDS460 - Decision Analytics/Module 6 Assignment/Data/VirginiaCounty.shp')

# Assuming 'gdf' is the GeoDataFrame loaded from the shapefile as in your provided code.
for index, row in gdf.iterrows():
    print(row['NAMELSAD'])

def style_function(feature):
        return {
            'fillColor': '#ffff00',
            'color': '#000000',
            'weight': 0.5,
            'fillOpacity': 0.5,
        }

    def highlight_function(feature):
        return {
            'fillColor': '#0000ff',
            'color': '#000000',
            'weight': 1,
            'fillOpacity': 0.7,
        }

# Create a folium map centered on Virginia
m = folium.Map(location=[37.54, -77.46], zoom_start=8) # Virginia coordinates

# Add a Chloropleth layer to the map
folium.Choropleth(
    geo_data=gdf,  # Your GeoJSON data
    name='Virginia Population',
    data=df,  # Your DataFrame with population data
    columns=['County/City', 'Population'],
    key_on='feature.properties.NAMELSAD', # Assuming your GeoJSON features have a 'NAME' property matching your DataFrame
    fill_color='YlOrRd',
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name='Population',
    highlight=True,
).add_to(m)

folium.GeoJson(
        gdf,
        style_function=style_function,
        highlight_function=highlight_function,
        tooltip=folium.GeoJsonTooltip(
            fields=['NAMELSAD'],  # Display 'name' field on hover
            aliases=['County/City:'],
            sticky=True,
        )
    ).add_to(m)

# Display the map
m

gdf_district = gpd.read_file('/content/drive/MyDrive/MSDS460 - Decision Analytics/Module 6 Assignment/Data/VirginiaCongressional2010.shp')

# Function to assign a color to each district
def color_map(feature):
    # Use the district ID to select a color
    n = len(gdf_district)
    cmap = plt.cm.get_cmap('tab20', n)  # Using 'tab20' colormap with n colors
    district_id = feature['properties']['ID']  # Assumes each feature has a 'DISTRICT_ID' property
    color = cmap(district_id / n)
    return {
        'fillColor': to_hex(color),
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.5,
    }

# Create a folium map centered on Virginia
m = folium.Map(location=[37.54, -77.46], zoom_start=8)




# Add the districts layer with different colors
folium.GeoJson(

    gdf_district,
    style_function=color_map,
    highlight_function=highlight_function,
    tooltip=folium.GeoJsonTooltip(
        fields=['DISTRICT'],
        aliases=['District:'],
        sticky=True
    )
).add_to(m)

folium.GeoJson(
    gdf,
    style_function=lambda feature: {
        'fillColor': 'none',
        'color': 'black',
        'weight': 2
    },
    tooltip=folium.GeoJsonTooltip(
        fields=['NAMELSAD'],  # Display 'NAMELSAD' field on hover
        aliases=['County/City:'],
        sticky=True,
    )
).add_to(m)

# Show the map
m

"""## Base Model

In this scenario, "Fairness" is defined as having the most equitable distribution of popultion.
"""

!pip install pulp
import pulp

base_model_df = df
base_model_df['Population'] = base_model_df['Population'].astype(int)
base_num_districts = 11
base_population_sum = base_model_df['Population'].sum()
base_target_population = base_population_sum // base_num_districts
print(f"The target population is: {base_target_population:,} per district with a total of {base_num_districts} districts.")


# Define the problem
prob = pulp.LpProblem("RedistrictingBase", pulp.LpMinimize)

# Convert df to a dict
county_cities = df.to_dict(orient='index')

# Extract counties/cities data
counties = list(county_cities.keys())
populations = {key: value['Population'] for key, value in county_cities.items()}

# Variables
x = pulp.LpVariable.dicts("x", [(i, j) for i in counties for j in range(base_num_districts)], cat='Binary')

# Auxiliary variables to represent absolute differences
abs_diff = pulp.LpVariable.dicts("abs_diff", [j for j in range(base_num_districts)], lowBound=0, cat='Continuous')

# Objective function: Minimize the sum of absolute differences
prob += pulp.lpSum(abs_diff[j] for j in range(base_num_districts))

# Constraints
# Each county must be in exactly one district
for i in counties:
    prob += pulp.lpSum(x[i, j] for j in range(base_num_districts)) == 1


# Constraints to link absolute differences with district populations
for j in range(base_num_districts):
    district_pop = pulp.lpSum([populations[i] * x[(i, j)] for i in counties])
    prob += district_pop - base_target_population <= abs_diff[j]  # Upper bound
    prob += base_target_population - district_pop <= abs_diff[j]  # Lower bound


# Solve the problem
print("\n\nSolving Problem\n\n")
prob.solve()

# Output status of problem
print(f"Problem Status: {pulp.LpStatus[prob.status]}\n")

# Output the results
for i in counties:
    for j in range(base_num_districts):
        if pulp.value(x[i, j]) == 1:
            print(f"County {county_cities[i]['County/City']} (GEOID: {i}) is in District {j}")

district_assignments = {}
for i in counties:
    for j in range(base_num_districts):
        if pulp.value(x[i, j]) == 1:
            district_assignments[i] = j + 1

# Create a new column 'District' in base_model_df
base_model_df['District'] = base_model_df.index.map(district_assignments)

# Handle counties that were not assigned to a district (if any)
base_model_df['District'] = base_model_df['District'].fillna(-1)

"""## Optimizing for Homeownership Percentages"""

import pulp
import numpy as np
import pulp
import numpy as np

# Define the model
k = 11

target_homeownership_rate = 69.1  # Target is 69.1% for the entire state

# Define the linear programming problem
homeownership_model = pulp.LpProblem("Virginia_Redistricting_Homeownership", pulp.LpMinimize)

# Define decision variables for each county and district
y = pulp.LpVariable.dicts("y", (counties, range(k)), cat="Binary")

# Auxiliary variable for each district to represent the total homeownership sum
district_homeownership_sum = pulp.LpVariable.dicts("district_homeownership_sum", range(k), lowBound=0)

# Define the absolute deviation variables for each district
deviation = pulp.LpVariable.dicts("deviation", range(k), lowBound=0)

# Objective: Minimize the sum of deviations from the target homeownership rate
homeownership_rates = df.set_index("County/City")["Homeownership_Percentage"].to_dict()
# List of counties
counties = list(homeownership_rates.keys())
for j in range(k):  # Iterate over districts
    # Sum of homeownership rates for counties assigned to district j
    weighted_homeownership_sum = pulp.lpSum(y[i][j] * homeownership_rates[i] for i in counties)

    # Set the constraint that district_homeownership_sum represents the sum of homeownership rates
    homeownership_model += district_homeownership_sum[j] == weighted_homeownership_sum

    # Add a constraint for the absolute deviation from the target homeownership rate
    homeownership_model += deviation[j] >= district_homeownership_sum[j] - target_homeownership_rate * pulp.lpSum(y[i][j] for i in counties)
    homeownership_model += deviation[j] >= target_homeownership_rate * pulp.lpSum(y[i][j] for i in counties) - district_homeownership_sum[j]

# Add the objective function (sum of absolute deviations)
homeownership_model += pulp.lpSum(deviation[j] for j in range(k))

# Constraints: Each county must be assigned to exactly one district
for i in counties:
    homeownership_model += pulp.lpSum(y[i][j] for j in range(k)) == 1  # County i must be assigned to exactly one district

# Step 7: Solve the problem
homeownership_model.solve()

# Step 8: Output the results

# Debugging: Check if counties are being assigned to districts
assigned_counties_per_district = {j: [] for j in range(k)}

for i in counties:
    for j in range(k):
        if pulp.value(y[i][j]) > 0.5:  # If county i is assigned to district j
            assigned_counties_per_district[j].append(i)

# Print which counties are assigned to each district
print("Assigned counties per district:")
for j in range(k):
    print(f"District {j}: {assigned_counties_per_district[j]}")

# For each district, calculate the total homeownership sum and the number of counties assigned
district_homeownership_percentage = {}

for j in range(k):
    total_homeownership = pulp.value(district_homeownership_sum[j])  # Get the total homeownership sum for the district
    assigned_counties = assigned_counties_per_district[j]  # Counties assigned to district j
    num_counties = len(assigned_counties)

    # Calculate the average homeownership percentage for the district
    if num_counties > 0:
        average_homeownership_percentage = total_homeownership / num_counties
    else:
        average_homeownership_percentage = 0  # If no counties are assigned to the district

    district_homeownership_percentage[j] = average_homeownership_percentage

# Display the average homeownership percentage for each district
for j in range(k):
    print(f"District {j} - Average Homeownership Rate: {district_homeownership_percentage[j]:.2f}%")

# Group by district and sum the population
district_populations = base_model_df.groupby('District')['Population'].sum()

# Get the county names for each district
district_counties = base_model_df.groupby('District')['County/City'].apply(list)

# Combine the results into a DataFrame
result_df = pd.DataFrame({'Population': district_populations, 'Counties': district_counties})

result_df

# Ensure every county in gdf_base has a district mapping
district_mapping_base = base_model_df['District'].to_dict()
gdf_base = gdf.set_index('STCOFIPS')
gdf_base.index = gdf_base.index.astype(int)

# Map the district numbers to the gdf_base based on the GEOID
# If a district number is missing, assign it a default value (-1 or any placeholder)
gdf_base['District'] = gdf_base.index.map(district_mapping_base).fillna(-1).astype(int)

# Function to assign a color to each district
def color_map_base(feature):
    # Use the district ID to select a color
    n = 11
    cmap = plt.cm.get_cmap('tab20', n)  # Using 'tab20' colormap with n colors
    district_id = feature['properties']['District']

    # Handle invalid district IDs
    if district_id == -1:
        # Use a default color (gray or any color you prefer for missing districts)
        color = (0.5, 0.5, 0.5)  # Gray color for invalid districts
    else:
        color = cmap(district_id / n)

    return {
        'fillColor': to_hex(color),
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.5,
    }

# Create a folium map centered on Virginia
m = folium.Map(location=[37.54, -77.46], zoom_start=8)

# Add GeoJSON layer with custom style function using color_map_base
folium.GeoJson(
    gdf_base,
    style_function=color_map_base,
    tooltip=folium.GeoJsonTooltip(
        fields=['NAMELSAD', 'District'],  # Display 'NAMELSAD' and 'District' fields on hover
        aliases=['County/City:', 'District:'],
        sticky=True,
    )
).add_to(m)

m

# Create a folium map centered on Virginia
m = folium.Map(location=[37.54, -77.46], zoom_start=8)

# Add the counties layer with colors based on the district assignments
folium.Choropleth(
    geo_data=gdf,
    name='Virginia Districts',
    data=base_model_df,
    columns=['County/City', 'District'],  # Use 'NAMELSAD' to match GeoJSON and 'District' for coloring
    key_on='feature.properties.NAMELSAD',
    fill_color='Set1',  # Choose a categorical colormap
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name='District',
    highlight=True,
).add_to(m)

folium.GeoJson(
    gdf,
    style_function=lambda feature: {
        'fillColor': 'black',
        'color': 'black',
        'weight': 2,
        'fill_opacity':0.1
    },
    tooltip=folium.GeoJsonTooltip(
        fields=['NAMELSAD'],  # Display 'NAMELSAD' field on hover
        aliases=['County/City:'],
        sticky=True,
    )
).add_to(m)

# Show the map
m

"""## Adding Contiguity"""

gdf['centroid'] = gdf.geometry.centroid
gdf['X'] = gdf['centroid'].x
gdf['Y'] = gdf['centroid'].y

gdf_wgs84 = gdf.to_crs(epsg=4326)
# Get the x-coordinate of the centroid of each geometry
gdf_wgs84['x'] = gdf_wgs84.geometry.centroid.x
gdf_wgs84['y'] = gdf_wgs84.geometry.centroid.y
gdf_wgs84.drop(columns=['X','Y'], inplace=True)
gdf.drop(columns=['X','Y','centroid'], inplace=True)
gdf_wgs84.head()

!pip install geopy
# what is the "distance" between Payne County (node 0), Oklahoma County (node 15), and Tulsa County (node 23)?
from geopy.distance import geodesic

# Find the coordinates for Accomack and Albemarle counties
accomack_coords = gdf_wgs84[gdf_wgs84['NAMELSAD'] == 'Accomack County']
albemarle_coords = gdf_wgs84[gdf_wgs84['NAMELSAD'] == 'Albemarle County']

if not accomack_coords.empty and not albemarle_coords.empty:
  accomack_coords = (accomack_coords['y'].iloc[0], accomack_coords['x'].iloc[0])
  albemarle_coords = (albemarle_coords['y'].iloc[0], albemarle_coords['x'].iloc[0])

  # Calculate the distance using geopy.distance
  distance = geodesic(accomack_coords, albemarle_coords).miles
  print(f"The distance between Accomack County and Albemarle County is: {distance} miles")
else:
  print("Accomack or Albemarle County not found in the GeoDataFrame.")

# Set the index of gdf_wgs84 to match the index of df
gdf_wgs84 = gdf_wgs84.set_index(df.index)
gdf_wgs84.head()

dist = dict()
for i in gdf_wgs84.index:
    for j in gdf_wgs84.index:
        coords_i = (gdf_wgs84.loc[i, 'y'], gdf_wgs84.loc[i, 'x'])
        coords_j = (gdf_wgs84.loc[j, 'y'], gdf_wgs84.loc[j, 'x'])
        dist[i,j] = geodesic(coords_i, coords_j).miles

dist[51001,51003]

# Let's impose a 10% population deviation (+/- 15%)
deviation = 0.30

import math
k = 11          # number of districts
total_population = df['Population'].sum()

L = math.ceil((1-deviation/2)*total_population/k)
U = math.floor((1+deviation/2)*total_population/k)
print("Using L =",L,"and U =",U,"and k =",k)

import networkx as nx

prob = pulp.LpProblem("Redistricting", pulp.LpMinimize)

# create x[i,j] variable which equals one when county i
#    is assigned to (the district centered at) county j
x = pulp.LpVariable.dicts("x", [(i, j) for i in counties for j in counties], cat='Binary')

# Objective function: Minimize the sum of squared distances weighted by population
prob += pulp.lpSum(dist[i, j]**2 * base_model_df.loc[i, 'Population'] * x[i, j] for i in counties for j in counties)

# add constraints saying that each county i is assigned to one district
for i in counties:
    prob += pulp.lpSum(x[i, j] for j in counties) == 1

# add constraint saying there should be k district centers
prob += pulp.lpSum(x[j, j] for j in counties) == k

# #Lower bound constraint
# for j in counties:
#     prob += pulp.lpSum(base_model_df.loc[i, 'Population'] * x[i, j] for i in counties) >= L * x[j, j]

# Add the constraint to ensure that if i is assigned to j, then j must be a district center
for i in counties:
    for j in counties:
        prob += x[i, j] <= x[j, j]

base_model_df

# Create a directed graph
DG = nx.DiGraph()

# Add nodes to the graph (counties/cities)
for county in df.index:
    DG.add_node(county)

# Add edges based on adjacency information
for index, row in df.iterrows():
    county = index
    neighbors = row['Neighbor Names']
    neighbor_geoids = row['Neighbor GEOIDs']

    for i, neighbor in enumerate(neighbors):
      neighbor_geoid = neighbor_geoids[i]
      # Add directed edges between the county and its neighbors.
      if neighbor_geoid in DG:
        DG.add_edge(county, neighbor_geoid)
        DG.add_edge(neighbor_geoid, county)

# Now you have a directed graph 'G' representing the relationships between counties/cities
print(f"Number of nodes in the graph: {DG.number_of_nodes()}")
print(f"Number of edges in the graph: {DG.number_of_edges()}")

# Add flow variables
f = pulp.LpVariable.dicts("f", [(j, u, v) for j in DG.nodes for u, v in DG.edges], lowBound=0, cat='Continuous')
M = len(DG.nodes) - 1

# Add constraint saying that node j cannot receive flow of its own type
for j in DG.nodes:
    for u in DG.neighbors(j):
        prob += pulp.lpSum(f[j, u, j] for u in DG.neighbors(j)) == 0

# Add constraints saying that node i can receive flow of type j only if i is assigned to j
for i in DG.nodes:
    for j in DG.nodes:
        if i != j:
            prob += pulp.lpSum(f[j, u, i] for u in DG.neighbors(i) if (j, u, i) in f) <= M * x[i, j]

# If i is assigned to j, then i should consume one unit of j flow. Otherwise, i should consume no units of j flow.
for i in DG.nodes:
    for j in DG.nodes:
        if i != j:
            prob += pulp.lpSum(f[j, u, i] - f[j, i, u] for u in DG.neighbors(i) if (j, u, i) in f and (j, i, u) in f) == x[i, j]

# Solve the problem with detailed output
print("\n\nSolving Problem\n\n")
prob.solve(pulp.PULP_CBC_CMD(msg=True))
# Output status of problem
print(f"Problem Status: {pulp.LpStatus[prob.status]}\n")

# Retrieve the districts and their populations
centers = [j for j in counties if pulp.value(x[j, j]) > 0.5]
districts = [[i for i in counties if pulp.value(x[i, j]) > 0.5] for j in centers]
district_counties = [[base_model_df.loc[i, 'County/City'] for i in districts[j]] for j in range(k)]
district_populations = [sum(base_model_df.loc[i, 'Population'] for i in districts[j]) for j in range(k)]

# Print the results
print("Centers:", centers)
print("Districts:", districts)
print("District Counties:", district_counties)
print("District Populations:", district_populations)

base_model_contiguous_df = base_model_df.drop(columns=['District'])

for n,district in enumerate(districts):
    for county in district:
        base_model_contiguous_df.loc[county,'District'] = n+1
base_model_contiguous_df['District'] = base_model_contiguous_df['District'].astype(int)
base_model_contiguous_df

# Group by district and sum the population
district_populations = base_model_contiguous_df.groupby('District')['Population'].sum()

# Get the county names for each district
district_counties = base_model_contiguous_df.groupby('District')['County/City'].apply(list)

# Combine the results into a DataFrame
result_df = pd.DataFrame({'Population': district_populations, 'Counties': district_counties})
result_df['Deviation'] = (result_df['Population'] - base_target_population)
result_df

district_mapping_contiguous = base_model_contiguous_df['District'].to_dict()
gdf_contiguous_df = gdf.set_index('STCOFIPS')
gdf_contiguous_df.index = gdf_contiguous_df.index.astype(int)

# Map the district numbers to the gdf_contiguous_df based on the GEOID
gdf_contiguous_df['District'] = gdf_contiguous_df.index.map(district_mapping_contiguous)

# Function to assign a color to each district
def color_map_contiguous(feature):
    # Use the district ID to select a color
    n = 11
    cmap = plt.cm.get_cmap('tab20', n)  # Using 'tab20' colormap with n colors
    district_id = feature['properties']['District']
    color = cmap(district_id / n)
    return {
        'fillColor': to_hex(color),
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.5,
    }

# Create a folium map centered on Virginia
m = folium.Map(location=[37.54, -77.46], zoom_start=8)

# Add GeoJSON layer with custom style function using color_map_contiguous
folium.GeoJson(
    gdf_contiguous_df,
    style_function=color_map_contiguous,
    tooltip=folium.GeoJsonTooltip(
        fields=['NAMELSAD', 'District'],  # Display 'NAMELSAD' and 'District' fields on hover
        aliases=['County/City:', 'District:'],
        sticky=True,
    )
).add_to(m)

m

"""# Adding Historical Voting Information"""

try:
    election_df = pd.read_csv("https://historical.elections.virginia.gov/elections/download/144567/precincts_include:0/")
    print(election_df.head())
except Exception as e:
    print(f"An error occurred: {e}")

# Drop the first row
election_df = election_df.drop(0).reset_index(drop=True)

# Drop the second and third columns
election_df = election_df.drop(['Unnamed: 1', 'Unnamed: 2'], axis=1)

# Manually specify the column names (adjust these as per your dataset)
election_df.columns = ['County/City', 'Democratic', 'Republican', 'Libertarian', 'All Others','Total Votes']

# Drop the last row
election_df = election_df.drop(election_df.index[-1])

# Set the columns as integers
election_df['Democratic'] = pd.to_numeric(election_df['Democratic'].str.replace(',', ''), errors='coerce').astype('Int64')
election_df['Republican'] = pd.to_numeric(election_df['Republican'].str.replace(',', ''), errors='coerce').astype('Int64')
election_df['Libertarian'] = pd.to_numeric(election_df['Libertarian'].str.replace(',', ''), errors='coerce').astype('Int64')
election_df['All Others'] = pd.to_numeric(election_df['All Others'].str.replace(',', ''), errors='coerce').astype('Int64')
election_df['Total Votes'] = pd.to_numeric(election_df['Total Votes'].str.replace(',', ''), errors='coerce').astype('Int64')

# Now df will have the desired column names, second and third columns removed, and the last row dropped
election_df.head()

# Unique county names in the original DataFrame
df_counties = set(df['County/City'].unique())

# Unique county names in the election DataFrame
election_counties = set(election_df['County/City'].unique())

# Counties present in df but not in filtered_df
counties_only_in_df = df_counties - election_counties

# Counties present in filtered_df but not in df
counties_only_in_election = election_counties - df_counties

# Print the results
print("Counties present in df but not in election_df:")
for county in counties_only_in_df:
    print(county)

print("\nCounties present in election_df but not in df:")
for county in counties_only_in_election:
    print(county)

len(election_df['County/City'].unique())

# Ensure consistent county names
election_df['County/City'] = election_df['County/City'].str.strip()

# Merge election_df with df to get County GEOID
election_df = election_df.merge(df.reset_index()[['County GEOID', 'County/City']], on='County/City', how='left')

# Set County GEOID as index
election_df.set_index('County GEOID', inplace=True)

# Convert 'election_df' to a dictionary for easier access
election_data = election_df.copy()

# Create a mapping of 'County GEOID' to its political proportions
political_proportions = {
    idx: {
        'Democratic': election_data.loc[idx, 'Democratic'] / election_data.loc[idx, 'Total Votes'],
        'Republican': election_data.loc[idx, 'Republican'] / election_data.loc[idx, 'Total Votes'],
        'Libertarian': election_data.loc[idx, 'Libertarian'] / election_data.loc[idx, 'Total Votes'],
        'All Others': election_data.loc[idx, 'All Others'] / election_data.loc[idx, 'Total Votes']
    }
    for idx in election_data.index if idx in election_data.index
}

# Get list of counties (GEOIDs)
counties = list(df.index)

# Define LP problem
prob = pulp.LpProblem("Redistricting", pulp.LpMinimize)

# Define decision variables
# x = pulp.LpVariable.dicts("x", [(i, j) for i in counties for j in counties], cat='Binary')
x = pulp.LpVariable.dicts("x", [(i, j) for i in counties for j in range(base_num_districts)], cat='Binary')


# Objective function: Minimize the sum of squared distances weighted by population
# prob += pulp.lpSum(dist[i, j]**2 * df.loc[i, 'Population'] * x[i, j] for i in counties for j in counties)
# prob += pulp.lpSum(dist[i, j]**2 * df.loc[i, 'Population'] * x[i, j] for i in counties for j in counties)
# prob += pulp.lpSum(dist[i, j]**2 * df.loc[i, 'Population'] * x[i, j] for i in counties for j in counties if (i, j) in dist)
#prob += pulp.lpSum(dist[i, j]**2 * base_model_df.loc[i, 'Population'] * x[i, j] for i in counties for j in counties)


# Assign each county to one district
for i in counties:
    prob += pulp.lpSum(x[i, j] for j in counties) == 1

# Ensure k district centers
prob += pulp.lpSum(x[j, j] for j in counties) == k

# Add flow constraints (ensure contiguity)
f = pulp.LpVariable.dicts("f", [(j, u, v) for j in DG.nodes for u, v in DG.edges], lowBound=0, cat='Continuous')
for j in DG.nodes:
    for u in DG.neighbors(j):
        prob += pulp.lpSum(f[j, u, j] for u in DG.neighbors(j)) == 0

# Political Fairness Objective: Balance political compositions
# for j in range(base_num_districts):
#     prob += pulp.lpSum(
#         (political_proportions[i]['Democratic'] - political_proportions[i]['Republican']) * x[i, j]
#         for i in counties
#     )
for j in range(base_num_districts):
    prob += pulp.lpSum(
        (political_proportions[i]['Democratic'] - political_proportions[i]['Republican']) * x[i, j]
        for i in counties if i in political_proportions
    )

# Ensure valid district assignment
for i in counties:
    for j in counties:
        prob += x[i, j] <= x[j, j]

# Solve problem
prob.solve()

# Output status
print(f"Problem Status: {pulp.LpStatus[prob.status]}\n")

# Store district assignments
district_assignments = {i: j+1 for i in counties for j in range(base_num_districts) if pulp.value(x[i, j]) == 1}

# Assign districts in df
df['District'] = df.index.map(district_assignments)

missing_x = [(i, j) for i in counties for j in range(base_num_districts) if (i, j) not in x]
print(f"Missing x[i, j] variables: {missing_x}")

dist



"""##Adding Homeownership Rates"""

import pandas as pd

# Create a dictionary of homeownership rates for each county
homeownership_rates = {
    "Accomack County":	68.78409,
    "Albemarle County":	70.12396,
    "Alexandria City":	43.53202,
    "Alleghany County":	79.76027,
    "Amelia County":	80.00757,
    "Amherst County":	80.08371,
    "Appomattox County":	77.15789,
    "Arlington County":	48.02977,
    "Augusta County":	81.12794,
    "Bath County":	70.66294,
    "Bedford City":	65,
    "Bedford County":	85.45981,
    "Bland County":	76.55303,
    "Botetourt County":	87.8883,
    "Bristol City":	66.59289,
    "Brunswick County":	68.98669,
    "Buchanan County":	80.91021,
    "Buckingham County":	74.53098,
    "Buena Vista City":	58.30033,
    "Campbell County":	78.07618,
    "Caroline County":	82.3192,
    "Carroll County":	76.8283,
    "Charles City County":	84.57972,
    "Charlotte County":	70.59915,
    "Charlottesville City":	46.14828,
    "Chesapeake City":	76.52256,
    "Chesterfield County":	78.73646,
    "Clarke County":	84.65963,
    "Colonial Heights City":	72.46007,
    "Covington City":	72.40824,
    "Craig County":	88.04191,
    "Culpeper County":	74.80606,
    "Cumberland County":	77.55922,
    "Danville City":	47.52132,
    "Dickenson County":	75.52021,
    "Dinwiddie County":	77.79933,
    "Emporia City":	33.55494,
    "Essex County":	70.12591,
    "Fairfax City":	69.6712,
    "Fairfax County":	70.24715,
    "Falls Church City":	57.78284,
    "Fauquier County":	80.35807,
    "Floyd County":	82.22265,
    "Fluvanna County":	90.53487,
    "Franklin City":	47.09454,
    "Franklin County":	80.07794,
    "Frederick County":	80.28485,
    "Fredericksburg City":	47.02616,
    "Galax City":	66.63016,
    "Giles County":	79.11473,
    "Gloucester County":	81.80231,
    "Goochland County":	88.38115,
    "Grayson County":	80.74747,
    "Greene County":	77.54915,
    "Greensville County":	62.31443,
    "Halifax County":	72.06424,
    "Hampton City":	58.16798,
    "Hanover County":	84.71229,
    "Harrisonburg City":	40.398,
    "Henrico County":	67.31163,
    "Henry County":	77.83409,
    "Highland County":	89.88962,
    "Hopewell City":	52.81482,
    "Isle of Wight County":	84.31277,
    "James City County":	80.89182,
    "King and Queen County":	71.15039,
    "King George County":	78.5869,
    "King William County":	89.80997,
    "Lancaster County":	80.57676,
    "Lee County":	75.34527,
    "Lexington City":	50.02396,
    "Loudoun County":	81.20593,
    "Louisa County":	82.44883,
    "Lunenburg County":	71.80369,
    "Lynchburg City":	52.25775,
    "Madison County":	78.59235,
    "Manassas City":	70.39741,
    "Manassas Park City":	71.18794,
    "Martinsville City":	60.30912,
    "Mathews County":	84.35374,
    "Mecklenburg County":	71.69228,
    "Middlesex County":	82.73298,
    "Montgomery County":	55.29721,
    "Nelson County":	79.98227,
    "New Kent County":	91.03372,
    "Newport News City":	49.94065,
    "Norfolk City":	48.7666,
    "Northampton County":	66.91189,
    "Northumberland County":	89.49938,
    "Norton City":	56.06061,
    "Nottoway County":	69.22665,
    "Orange County":	79.82696,
    "Page County":	71.05151,
    "Patrick County":	80.54909,
    "Petersburg City":	40.22761,
    "Pittsylvania County":	78.15617,
    "Poquoson City":	86.6341,
    "Portsmouth City":	57.00036,
    "Powhatan County":	94.36696,
    "Prince Edward County":	63.81602,
    "Prince George County":	69.34708,
    "Prince William County":	76.40833,
    "Pulaski County":	72.65608,
    "Radford City":	42.07854,
    "Rappahannock County":	73.19546,
    "Richmond City":	46.48633,
    "Richmond County":	70.5161,
    "Roanoke City":	53.78448,
    "Roanoke County":	78.91381,
    "Rockbridge County":	78.46251,
    "Rockingham County":	74.92478,
    "Russell County":	75.83717,
    "Salem City":	70.20898,
    "Scott County":	78.51017,
    "Shenandoah County":	73.64099,
    "Smyth County":	72.22858,
    "Southampton County":	76.72627,
    "Spotsylvania County":	82.02686,
    "Stafford County":	82.37588,
    "Staunton City":	63.1444,
    "Suffolk City":	72.46989,
    "Surry County":	81.74603,
    "Sussex County":	67.80461,
    "Tazewell County":	73.58771,
    "Virginia Beach City":	67.44434,
    "Warren County":	77.4685,
    "Washington County":	78.11981,
    "Waynesboro City":	65.41044,
    "Westmoreland County	":	79.68649,
    "Williamsburg City":	52.63696,
    "Winchester City":	45.85613,
    "Wise County":	73.99682,
    "Wythe County":	79.71573,
    "York County": 72.06923

}

# List of counties
counties = list(homeownership_rates.keys())

# Convert to a DataFrame
homeownership_df = pd.DataFrame(list(homeownership_rates.items()), columns=["County/City", "Homeownership Rate"])

# Calculate the target homeownership rate (in this case, 69.1% for Virginia)
target_homeownership_rate = 69.1

# Ensure consistent county names
homeownership_df['County/City'] = homeownership_df['County/City'].str.strip()

# Merge election_df with df to get County GEOID
homeownership_df = homeownership_df.merge(df.reset_index()[['County GEOID', 'County/City']], on='County/City', how='left')

# Set County GEOID as index
homeownership_df.set_index('County GEOID', inplace=True)

import pulp
import numpy as np
import pulp
import numpy as np

# Define the model
k = 11
  # Assume we are dividing into 5 districts
target_homeownership_rate = 65  # Target is 69.1% for the entire state

# Define the linear programming problem
homeownership_model = pulp.LpProblem("Virginia_Redistricting_Homeownership", pulp.LpMinimize)

# Define decision variables for each county and district
y = pulp.LpVariable.dicts("y", (counties, range(k)), cat="Binary")

# Auxiliary variable for each district to represent the total homeownership sum
district_homeownership_sum = pulp.LpVariable.dicts("district_homeownership_sum", range(k), lowBound=0)

# Define the absolute deviation variables for each district
deviation = pulp.LpVariable.dicts("deviation", range(k), lowBound=0)

# Objective: Minimize the sum of deviations from the target homeownership rate
for j in range(k):  # Iterate over districts
    # Sum of homeownership rates for counties assigned to district j
    weighted_homeownership_sum = pulp.lpSum(y[i][j] * homeownership_rates[i] for i in counties)

    # Set the constraint that district_homeownership_sum represents the sum of homeownership rates
    homeownership_model += district_homeownership_sum[j] == weighted_homeownership_sum

    # Add a constraint for the absolute deviation from the target homeownership rate
    homeownership_model += deviation[j] >= district_homeownership_sum[j] - target_homeownership_rate * pulp.lpSum(y[i][j] for i in counties)
    homeownership_model += deviation[j] >= target_homeownership_rate * pulp.lpSum(y[i][j] for i in counties) - district_homeownership_sum[j]

# Add the objective function (sum of absolute deviations)
homeownership_model += pulp.lpSum(deviation[j] for j in range(k))

# Constraints: Each county must be assigned to exactly one district
for i in counties:
    homeownership_model += pulp.lpSum(y[i][j] for j in range(k)) == 1  # County i must be assigned to exactly one district

# Step 7: Solve the problem
homeownership_model.solve()

# Step 8: Output the results

# Debugging: Check if counties are being assigned to districts
assigned_counties_per_district = {j: [] for j in range(k)}

for i in counties:
    for j in range(k):
        if pulp.value(y[i][j]) > 0.5:  # If county i is assigned to district j
            assigned_counties_per_district[j].append(i)

# Print which counties are assigned to each district
print("Assigned counties per district:")
for j in range(k):
    print(f"District {j}: {assigned_counties_per_district[j]}")

# For each district, calculate the total homeownership sum and the number of counties assigned
district_homeownership_percentage = {}

for j in range(k):
    total_homeownership = pulp.value(district_homeownership_sum[j])  # Get the total homeownership sum for the district
    assigned_counties = assigned_counties_per_district[j]  # Counties assigned to district j
    num_counties = len(assigned_counties)

    # Calculate the average homeownership percentage for the district
    if num_counties > 0:
        average_homeownership_percentage = total_homeownership / num_counties
    else:
        average_homeownership_percentage = 0  # If no counties are assigned to the district

    district_homeownership_percentage[j] = average_homeownership_percentage

# Display the average homeownership percentage for each district
for j in range(k):
    print(f"District {j} - Average Homeownership Rate: {district_homeownership_percentage[j]:.2f}%")

#adding contiguity constraint

homeownership_df.head()